use pulldown_cmark::{
    Alignment, CodeBlockKind, CowStr, Event, HeadingLevel, Options, Parser as MdParser, Tag, TagEnd,
};

/// Markdown → Typst translation.
/// - Headings, emphasis, links, lists, quotes, tables → Typst
/// - **Code blocks & inline code are passed through unchanged Markdown**.
pub fn translate(md: &str, with_preamble: bool) -> anyhow::Result<String> {
    let mut opts = Options::empty();
    opts.insert(Options::ENABLE_TABLES);
    opts.insert(Options::ENABLE_FOOTNOTES);
    opts.insert(Options::ENABLE_STRIKETHROUGH);
    opts.insert(Options::ENABLE_TASKLISTS);

    let parser = MdParser::new_ext(md, opts);

    let mut out = String::new();
    if with_preamble {
        out.push_str("// Generated by md2typst\n");
        out.push_str("#set page(paper: \"us-letter\", margin: 1in)\n");
        out.push_str("#set text(size: 10.5pt)\n\n");
    }

    #[derive(Clone, Copy)]
    enum ListKind {
        Bullet,
        Ordered { index: u64 },
    }
    let mut list_stack: Vec<ListKind> = Vec::new();

    let mut in_table = false;
    let mut table_row: Vec<String> = Vec::new();
    let mut buf = String::new();

    // NEW: track fenced/indented code blocks; when true, we pass text verbatim.
    let mut in_code_block = false;

    for ev in parser {
        match ev {
            Event::Start(tag) => match tag {
                Tag::Paragraph => {}
                Tag::Heading { level, .. } => {
                    let n = match level {
                        HeadingLevel::H1 => 1,
                        HeadingLevel::H2 => 2,
                        HeadingLevel::H3 => 3,
                        HeadingLevel::H4 => 4,
                        HeadingLevel::H5 => 5,
                        HeadingLevel::H6 => 6,
                    };
                    out.push_str(&"=".repeat(n));
                    out.push(' ');
                }
                Tag::Emphasis => out.push_str("#emph["),
                Tag::Strong => out.push_str("#strong["),
                Tag::Strikethrough => out.push_str("#strike["),
                Tag::Link {
                    dest_url, title, ..
                } => {
                    out.push_str("#link(");
                    write_escaped(&mut out, &dest_url);
                    if !title.is_empty() {
                        out.push_str(", title: ");
                        write_string_literal(&mut out, &title);
                    }
                    out.push_str(")[");
                }
                Tag::Image { dest_url, .. } => {
                    out.push_str("#image(");
                    write_escaped(&mut out, &dest_url);
                    out.push_str(")\n");
                }
                Tag::BlockQuote => out.push_str("#quote["),
                Tag::List(start) => {
                    if let Some(n) = start {
                        list_stack.push(ListKind::Ordered { index: n });
                    } else {
                        list_stack.push(ListKind::Bullet);
                    }
                }
                Tag::Item => {
                    if list_stack.is_empty() {
                        out.push_str("- ");
                    } else {
                        match list_stack.last().unwrap() {
                            ListKind::Bullet => {
                                out.push_str(&format!("{}- ", "  ".repeat(list_stack.len() - 1)));
                            }
                            ListKind::Ordered { index } => {
                                out.push_str(&format!(
                                    "{}{}. ",
                                    "  ".repeat(list_stack.len() - 1),
                                    index
                                ));
                            }
                        }
                    }
                }
                Tag::CodeBlock(kind) => {
                    // Pass through Markdown fences unchanged.
                    in_code_block = true;
                    out.push_str("```");
                    if let CodeBlockKind::Fenced(lang) = kind {
                        if !lang.is_empty() {
                            out.push_str(&lang);
                        }
                    }
                    out.push('\n');
                }
                Tag::Table(aligns) => {
                    in_table = true;
                    out.push_str("#table(columns: (");
                    for (i, a) in aligns.iter().enumerate() {
                        if i > 0 {
                            out.push_str(", ");
                        }
                        let col = match a {
                            Alignment::Left => "left",
                            Alignment::Center => "center",
                            Alignment::Right => "right",
                            Alignment::None => "auto",
                        };
                        out.push_str(col);
                    }
                    out.push_str("))[\n");
                }
                Tag::TableRow => table_row.clear(),
                Tag::TableCell => buf.clear(),
                Tag::FootnoteDefinition(name) => {
                    out.push_str("#footnote[#emph[");
                    out.push_str(&escape_inline(name.as_ref()));
                    out.push_str("]: ");
                }
                _ => {}
            },
            Event::End(tag_end) => match tag_end {
                TagEnd::Paragraph => out.push_str("\n\n"),
                TagEnd::Heading { .. } => out.push_str("\n\n"),
                TagEnd::Emphasis | TagEnd::Strong | TagEnd::Strikethrough | TagEnd::Link => {
                    out.push(']')
                }
                TagEnd::BlockQuote => out.push_str("]\n\n"),
                TagEnd::List(_) => {
                    list_stack.pop();
                    out.push('\n');
                }
                TagEnd::Item => {
                    out.push('\n');
                    if let Some(ListKind::Ordered { index }) = list_stack.last_mut() {
                        *index += 1;
                    }
                }
                TagEnd::CodeBlock => {
                    // Close Markdown fence unchanged.
                    in_code_block = false;
                    out.push_str("```\n\n");
                }
                TagEnd::Table => {
                    in_table = false;
                    out.push_str("]\n\n");
                }
                TagEnd::TableRow => {
                    out.push_str("  [");
                    for (i, cell) in table_row.iter().enumerate() {
                        if i > 0 {
                            out.push_str("]  [");
                        }
                        out.push_str(cell);
                    }
                    out.push_str("]\n");
                }
                TagEnd::TableCell => {
                    table_row.push(buf.clone());
                    buf.clear();
                }
                TagEnd::FootnoteDefinition => out.push_str("]\n"),
                _ => {}
            },
            Event::Text(t) => {
                if in_code_block {
                    // VERBATIM inside fenced code
                    out.push_str(&t);
                } else if in_table {
                    buf.push_str(&escape_inline(&t));
                } else {
                    out.push_str(&escape_inline(&t));
                }
            }
            Event::Code(t) => {
                // Inline code: pass through unchanged (no escaping)
                out.push('`');
                out.push_str(&t);
                out.push('`');
            }
            Event::SoftBreak => {
                if in_code_block {
                    out.push('\n');
                } else {
                    out.push(' ');
                }
            }
            Event::HardBreak => {
                if in_code_block {
                    out.push('\n');
                } else {
                    out.push_str(" \\\n");
                }
            }
            Event::Rule => out.push_str("#line(length: 100%)\n\n"),
            Event::Html(html) => {
                if in_code_block {
                    out.push_str(&html);
                } else {
                    out.push_str(&escape_inline(&html));
                }
            }
            Event::FootnoteReference(name) => {
                out.push_str(&format!("[^{}]", escape_inline(&name)));
            }
            _ => {}
        }
    }

    Ok(out)
}

/// Keep LF/TAB; drop other control chars that sometimes confuse tools.
pub fn sanitize_text(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for ch in s.chars() {
        match ch {
            '\n' | '\t' => out.push(ch),
            c if c.is_control() => {}
            _ => out.push(ch),
        }
    }
    out
}

fn escape_inline(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 8);
    for ch in s.chars() {
        match ch {
            '#' | '[' | ']' | '\\' => {
                out.push('\\');
                out.push(ch);
            }
            _ => out.push(ch),
        }
    }
    out
}

fn write_escaped(dst: &mut String, s: &CowStr) {
    dst.push('"');
    for ch in s.chars() {
        match ch {
            '"' => dst.push_str("\\\""),
            '\\' => dst.push_str("\\\\"),
            _ => dst.push(ch),
        }
    }
    dst.push('"');
}

fn write_string_literal(dst: &mut String, s: &str) {
    dst.push('"');
    for ch in s.chars() {
        match ch {
            '"' => dst.push_str("\\\""),
            '\\' => dst.push_str("\\\\"),
            _ => dst.push(ch),
        }
    }
    dst.push('"');
}
