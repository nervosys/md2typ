use pulldown_cmark::{
    Alignment, CodeBlockKind, CowStr, Event, HeadingLevel, Options, Parser as MdParser, Tag, TagEnd,
};

/// Markdown → Typst translation.
/// Coverage: CommonMark + GFM (tables, strikethrough, task lists, footnotes).
/// Code blocks & inline code are passed through unchanged as Markdown fenced blocks.
///
/// Mapping notes:
/// - Headings: `H1..H6` → `=`, `==`, …, `======`
/// - Lists: each item starts on its own physical line; nested items indented by two spaces / depth
/// - Task lists: literal `[ ]` / `[x]` inside the item text (no Typst widget)
/// - Tables: header preserved; alignments mapped to Typst (`left|center|right|auto`)
/// - Links: `#link("dest")[text]`; **display text escapes `@`** as `\@`
/// - Footnotes: references render as `#super[id]`; definitions as `#footnote[#emph[id]: …]`
pub fn translate(md: &str, with_preamble: bool) -> anyhow::Result<String> {
    let mut opts = Options::empty();
    opts.insert(Options::ENABLE_TABLES);
    opts.insert(Options::ENABLE_FOOTNOTES);
    opts.insert(Options::ENABLE_STRIKETHROUGH);
    opts.insert(Options::ENABLE_TASKLISTS);

    let parser = MdParser::new_ext(md, opts);

    let mut out = String::new();
    if with_preamble {
        out.push_str("// Generated by md2typst\n");
        out.push_str("#set page(paper: \"us-letter\", margin: 1in)\n");
        out.push_str("#set text(size: 10.5pt)\n\n");
    }

    #[derive(Clone, Copy)]
    enum ListKind {
        Bullet,
        Ordered { index: u64 },
    }
    let mut list_stack: Vec<ListKind> = Vec::new();

    // Table state
    let mut in_table = false;
    let mut in_table_head = false;
    let mut table_row: Vec<String> = Vec::new();
    let mut buf = String::new(); // cell buffer

    // Code state
    let mut in_code_block = false;

    // Link state
    let mut in_link = false;

    // Task list markers
    let mut pending_task_marker: Option<bool> = None; // Some(true)=checked

    // Footnotes
    let mut in_footnote_def: Option<String> = None;

    for ev in parser {
        match ev {
            Event::Start(tag) => match tag {
                Tag::Paragraph => {
                    // no-op; text follows
                }
                Tag::Heading { level, .. } => {
                    let n = match level {
                        HeadingLevel::H1 => 1,
                        HeadingLevel::H2 => 2,
                        HeadingLevel::H3 => 3,
                        HeadingLevel::H4 => 4,
                        HeadingLevel::H5 => 5,
                        HeadingLevel::H6 => 6,
                    };
                    out.push_str(&"=".repeat(n));
                    out.push(' ');
                }
                Tag::Emphasis => out.push_str("#emph["),
                Tag::Strong => out.push_str("#strong["),
                Tag::Strikethrough => out.push_str("#strike["),
                Tag::Link {
                    dest_url, title, ..
                } => {
                    let dst: &mut String = if in_table { &mut buf } else { &mut out };
                    dst.push_str("#link(");
                    write_escaped(dst, &dest_url);
                    if !title.is_empty() {
                        dst.push_str(", title: ");
                        write_string_literal(dst, &title);
                    }
                    dst.push_str(")["); // display text comes later via Event::Text
                    in_link = true;
                }
                Tag::Image { dest_url, .. } => {
                    let dst: &mut String = if in_table { &mut buf } else { &mut out };
                    dst.push_str("#image(");
                    write_escaped(dst, &dest_url);
                    dst.push_str(")\n");
                }
                Tag::BlockQuote => out.push_str("#quote["),
                Tag::List(start) => {
                    if let Some(n) = start {
                        list_stack.push(ListKind::Ordered { index: n });
                    } else {
                        list_stack.push(ListKind::Bullet);
                    }
                }
                Tag::Item => {
                    // Separate items clearly; indent by depth-1
                    let depth = list_stack.len().saturating_sub(1);
                    out.push('\n');
                    out.push_str(&"  ".repeat(depth));
                    match list_stack.last().unwrap_or(&ListKind::Bullet) {
                        ListKind::Bullet => out.push_str("- "),
                        ListKind::Ordered { index } => {
                            out.push_str(&format!("{}. ", index));
                        }
                    }
                    if let Some(checked) = pending_task_marker.take() {
                        if checked {
                            out.push_str("[x] ");
                        } else {
                            out.push_str("[ ] ");
                        }
                    }
                }
                Tag::CodeBlock(kind) => {
                    in_code_block = true;
                    out.push_str("```");
                    if let CodeBlockKind::Fenced(lang) = kind {
                        if !lang.is_empty() {
                            out.push_str(&lang);
                        }
                    }
                    out.push('\n');
                }
                Tag::Table(aligns) => {
                    in_table = true;
                    in_table_head = false;
                    out.push_str("#table(columns: (");
                    for (i, a) in aligns.iter().enumerate() {
                        if i > 0 {
                            out.push_str(", ");
                        }
                        let col = match a {
                            Alignment::Left => "left",
                            Alignment::Center => "center",
                            Alignment::Right => "right",
                            Alignment::None => "auto",
                        };
                        out.push_str(col);
                    }
                    out.push_str("))[\n");
                }
                Tag::TableHead => {
                    in_table_head = true;
                }
                Tag::TableRow => {
                    table_row.clear();
                }
                Tag::TableCell => {
                    buf.clear();
                }
                Tag::FootnoteDefinition(name) => {
                    in_footnote_def = Some(name.to_string());
                    out.push_str("#footnote[#emph[");
                    out.push_str(&escape_inline(name.as_ref()));
                    out.push_str("]: ");
                }
                _ => {}
            },

            Event::End(tag_end) => match tag_end {
                TagEnd::Paragraph => out.push_str("\n\n"),

                TagEnd::Heading { .. } => out.push_str("\n\n"),

                // Close inline style blocks (NOT links)
                TagEnd::Emphasis | TagEnd::Strong | TagEnd::Strikethrough => out.push(']'),

                // Close link (unit variant in pulldown-cmark 0.10)
                TagEnd::Link => {
                    let dst: &mut String = if in_table { &mut buf } else { &mut out };
                    dst.push(']');
                    in_link = false;
                }

                TagEnd::BlockQuote => out.push_str("]\n\n"),

                TagEnd::List(_) => {
                    list_stack.pop();
                    out.push('\n');
                }

                TagEnd::Item => {
                    out.push('\n');
                    if let Some(ListKind::Ordered { index }) = list_stack.last_mut() {
                        *index += 1;
                    }
                }

                TagEnd::CodeBlock => {
                    in_code_block = false;
                    out.push_str("```\n\n");
                }

                TagEnd::Table => {
                    in_table = false;
                    in_table_head = false;
                    out.push_str("]\n\n");
                }

                TagEnd::TableHead => {
                    in_table_head = false;
                }

                TagEnd::TableRow => {
                    // flush the row
                    out.push_str("  [");
                    for (i, cell) in table_row.iter().enumerate() {
                        if i > 0 {
                            out.push_str("]  [");
                        }
                        if in_table_head {
                            out.push_str("#strong[");
                            out.push_str(cell);
                            out.push(']');
                        } else {
                            out.push_str(cell);
                        }
                    }
                    out.push_str("]\n");
                }

                TagEnd::TableCell => {
                    table_row.push(buf.clone());
                    buf.clear();
                }

                TagEnd::FootnoteDefinition => {
                    in_footnote_def = None;
                    out.push_str("]\n");
                }

                _ => {}
            },

            Event::Text(t) => {
                if in_code_block {
                    // verbatim inside fenced code
                    out.push_str(&t);
                } else if in_table {
                    if in_link {
                        buf.push_str(&escape_inline_with_at(&t));
                    } else {
                        buf.push_str(&escape_inline(&t));
                    }
                } else if in_footnote_def.is_some() {
                    if in_link {
                        out.push_str(&escape_inline_with_at(&t));
                    } else {
                        out.push_str(&escape_inline(&t));
                    }
                } else {
                    if in_link {
                        out.push_str(&escape_inline_with_at(&t));
                    } else {
                        out.push_str(&escape_inline(&t));
                    }
                }
            }

            Event::Code(t) => {
                // Inline code: pass through unchanged
                out.push('`');
                out.push_str(&t);
                out.push('`');
            }

            Event::SoftBreak => {
                if in_code_block {
                    out.push('\n');
                } else if in_table {
                    buf.push(' ');
                } else {
                    out.push(' ');
                }
            }

            Event::HardBreak => {
                if in_code_block {
                    out.push('\n');
                } else if in_table {
                    buf.push_str(" \\\n");
                } else {
                    out.push_str(" \\\n");
                }
            }

            Event::Rule => out.push_str("#line(length: 100%)\n\n"),

            Event::Html(html) => {
                // Best-effort: escape as text unless in code
                if in_code_block {
                    out.push_str(&html);
                } else if in_table {
                    buf.push_str(&escape_inline(&html));
                } else {
                    out.push_str(&escape_inline(&html));
                }
            }

            Event::FootnoteReference(name) => {
                if in_table {
                    buf.push_str("#super[");
                    buf.push_str(&escape_inline(&name));
                    buf.push(']');
                } else {
                    out.push_str("#super[");
                    out.push_str(&escape_inline(&name));
                    out.push(']');
                }
            }

            Event::TaskListMarker(checked) => {
                pending_task_marker = Some(checked);
            }

            _ => {}
        }
    }

    Ok(out)
}

/// Keep LF/TAB; drop other C0 controls (prevents odd “invalid utf-8” reports by tools).
pub fn sanitize_text(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for ch in s.chars() {
        match ch {
            '\n' | '\t' => out.push(ch),
            c if c.is_control() => {}
            _ => out.push(ch),
        }
    }
    out
}

/// Escape inline Typst-breaking characters: `#`, `[`, `]`, `\`.
fn escape_inline(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 8);
    for ch in s.chars() {
        match ch {
            '#' | '[' | ']' | '\\' => {
                out.push('\\');
                out.push(ch);
            }
            _ => out.push(ch),
        }
    }
    out
}

/// Escape inline for link display text, also escaping `@` → `\@` (important for Typst).
fn escape_inline_with_at(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 8);
    for ch in s.chars() {
        match ch {
            '@' => out.push_str("\\@"),
            '#' | '[' | ']' | '\\' => {
                out.push('\\');
                out.push(ch);
            }
            _ => out.push(ch),
        }
    }
    out
}

/// Write a Typst string literal with escapes for `"` and `\`.
fn write_string_literal(dst: &mut String, s: &str) {
    dst.push('"');
    for ch in s.chars() {
        match ch {
            '"' => dst.push_str("\\\""),
            '\\' => dst.push_str("\\\\"),
            _ => dst.push(ch),
        }
    }
    dst.push('"');
}

/// Write a Typst string literal from a `CowStr` (URL, etc.).
fn write_escaped(dst: &mut String, s: &CowStr) {
    dst.push('"');
    for ch in s.chars() {
        match ch {
            '"' => dst.push_str("\\\""),
            '\\' => dst.push_str("\\\\"),
            _ => dst.push(ch),
        }
    }
    dst.push('"');
}
